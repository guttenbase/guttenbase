package io.github.guttenbase.export.plain

import io.github.guttenbase.utils.Util.forEach
import io.github.guttenbase.utils.Util.toHex
import java.io.*
import java.math.BigDecimal
import java.net.URL
import java.sql.*
import java.sql.Date
import java.time.format.DateTimeFormatter
import java.util.*


private val SQL_DATE_FORMAT = DateTimeFormatter.ofPattern("''yyyy-MM-dd''")
private val SQL_TIMESTAMP_FORMAT = DateTimeFormatter.ofPattern("''yyyy-MM-dd HH:mm:ss''")
private val SQL_TIME_FORMAT = DateTimeFormatter.ofPattern("''HH:mm:ss''")

/**
 * Connection info for exporting data to a file.
 *
 *  &copy; 2024-2044 akquinet tech@spree
 *
 * @author M. Dahm
 */
class ExportPlainTextStatement(sql: String, private val connection: ExportPlainTextConnection) : PreparedStatement {
  private var closed = false
  private var sql: String = ""
    set(sql) {
      if (!checkSQL(sql)) {
        throw UnsupportedOperationException("Statement not supported: $sql")
      }

      field = if (!sql.endsWith(';') && sql.isNotEmpty()) {
        "$sql;"
      } else {
        sql
      }
    }

  init {
    this.sql = sql
  }

  private val values = ArrayList<TO_STRING>(1000)

  private fun checkSQL(sql: String): Boolean {
    val trimmed = sql.uppercase().trim()

    return when {
      trimmed.isEmpty() -> true
      trimmed.startsWith("INSERT ") -> true
      trimmed.startsWith("UPDATE ") -> true
      else -> false
    }
  }

  override fun addBatch() {
    if (values.isNotEmpty() && sql.isNotEmpty()) {
      var count = 0
      var withinStringConstant = false

      for (i in sql.indices) {
        when (val ch = sql[i]) {
          '\'' -> {
            withinStringConstant = !withinStringConstant
            connection.printWriter.print('\'')
          }

          '?' -> if (!withinStringConstant) { // Replace ? placeholders if not within a string
            values[count++].invoke(connection.printWriter)
          } else {
            connection.printWriter.print('?')
          }

          else -> connection.printWriter.print(ch)
        }
      }

      connection.printWriter.println()
      values.clear()
    }
  }

  override fun addBatch(sql: String) {
    addBatch()
    this.sql = sql
  }

  override fun clearBatch() {
    sql = ""
  }

  override fun executeBatch() = intArrayOf(1)

  private fun setValue(parameterIndex: Int, value: String) {
    setValue(parameterIndex) { pw -> pw.print(value) }
  }

  private fun setValue(parameterIndex: Int, value: TO_STRING) {
    assert(parameterIndex - 1 == values.size) { "Adding parameters not executed in sequence" }

    values.ensureCapacity(parameterIndex + 100)
    values.add { value.invoke(it) }
  }

  override fun close() {
    if (sql.isNotBlank() && !closed) {
      executeUpdate()
    }

    closed = true
    sql = ""
  }

  override fun executeUpdate(): Int {
    addBatch()

    return 1
  }

  override fun executeUpdate(sql: String): Int {
    this.sql = sql
    return executeUpdate()
  }

  override fun executeUpdate(sql: String, autoGeneratedKeys: Int) = executeUpdate(sql)

  override fun executeUpdate(sql: String, columnIndexes: IntArray?) = executeUpdate(sql)

  override fun executeUpdate(sql: String, columnNames: Array<out String>) = executeUpdate(sql)

  override fun getConnection() = connection

  override fun execute() = execute(sql)

  override fun execute(sql: String): Boolean {
    executeUpdate(sql)
    return true
  }

  override fun execute(sql: String, autoGeneratedKeys: Int) = execute(sql)

  override fun execute(sql: String, columnIndexes: IntArray) = execute(sql)

  override fun execute(sql: String, columnNames: Array<out String>) = execute(sql)

  override fun getUpdateCount() = 1

  override fun isClosed() = closed

  override fun setNull(parameterIndex: Int, sqlType: Int) {
    setValue(parameterIndex, "NULL")
  }

  override fun setNull(parameterIndex: Int, sqlType: Int, typeName: String) {
    setValue(parameterIndex, "NULL")
  }

  override fun setBytes(parameterIndex: Int, x: ByteArray) {
    setValue(parameterIndex) { pw ->
      pw.print(databaseType.blobDataPrefix)
      pw.print(x.toHex())
      pw.print(databaseType.blobDataSuffix)
    }
  }

  override fun setObject(parameterIndex: Int, x: Any?) = when (x) {
    null -> setNull(parameterIndex, Types.BLOB)
    is ByteArray -> setBytes(parameterIndex, x)
    is String -> setString(parameterIndex, x)
    is Double -> setDouble(parameterIndex, x)
    is Boolean -> setBoolean(parameterIndex, x)
    is Byte -> setByte(parameterIndex, x)
    is Float -> setFloat(parameterIndex, x)
    is Short -> setShort(parameterIndex, x)
    is Long -> setLong(parameterIndex, x)
    is Int -> setInt(parameterIndex, x)
    is BigDecimal -> setBigDecimal(parameterIndex, x)
    is Date -> setDate(parameterIndex, x)
    is Timestamp -> setTimestamp(parameterIndex, x)
    is Time -> setTime(parameterIndex, x)
    is Serializable -> {
      val stream = ByteArrayOutputStream()
      ObjectOutputStream(stream).use { out -> out.writeObject(x) }
      setBytes(parameterIndex, stream.toByteArray())
    }

    else -> throw IllegalStateException("Cannot transform $x::${x.javaClass.name}")
  }

  override fun setObject(parameterIndex: Int, x: Any?, targetSqlType: Int) {
    setObject(parameterIndex, x)
  }

  override fun setObject(parameterIndex: Int, x: Any?, targetSqlType: Int, scaleOrLength: Int) {
    setObject(parameterIndex, x)
  }

  override fun setBlob(parameterIndex: Int, x: Blob?) {
    if (x != null) {
      setBlob(parameterIndex, x.binaryStream)
    } else {
      setNull(parameterIndex, Types.BLOB)
    }
  }

  override fun setBlob(parameterIndex: Int, inputStream: InputStream, length: Long) {
    setBlob(parameterIndex, inputStream)
  }

  override fun setBlob(parameterIndex: Int, x: InputStream) {
    setBinaryStream(parameterIndex, x)
  }

  override fun setBinaryStream(parameterIndex: Int, x: InputStream, length: Int) {
    setBinaryStream(parameterIndex, x)
  }

  override fun setBinaryStream(parameterIndex: Int, x: InputStream, length: Long) {
    setBinaryStream(parameterIndex, x)
  }

  private val databaseType = connection.connector.connectorInfo.databaseType

  override fun setBinaryStream(parameterIndex: Int, x: InputStream) {
    setValue(parameterIndex) { pw ->
      pw.print(databaseType.blobDataPrefix)
      x.forEach { pw.print(it.toHex()) }
      pw.print(databaseType.blobDataSuffix)
    }
  }

  override fun clearParameters() {
    values.clear()
  }

  override fun setClob(parameterIndex: Int, x: Clob?) {
    if (x != null) {
      setClob(parameterIndex, x.characterStream)
    } else {
      setNull(parameterIndex, Types.CLOB)
    }
  }

  override fun setClob(parameterIndex: Int, reader: Reader, length: Long) {
    setClob(parameterIndex, reader)
  }

  override fun setClob(parameterIndex: Int, reader: Reader) {
    setCharacterStream(parameterIndex, reader)
  }

  override fun setCharacterStream(parameterIndex: Int, reader: Reader, length: Int) {
    setCharacterStream(parameterIndex, reader)
  }

  override fun setCharacterStream(parameterIndex: Int, reader: Reader, length: Long) {
    setCharacterStream(parameterIndex, reader)
  }

  override fun setCharacterStream(parameterIndex: Int, reader: Reader) {
    setValue(parameterIndex) { pw -> reader.forEach { pw.print(it) } }
  }

  override fun setBoolean(parameterIndex: Int, x: Boolean) {
    setValue(parameterIndex, x.toString().uppercase())
  }

  override fun setByte(parameterIndex: Int, x: Byte) {
    setValue(parameterIndex, x.toString())
  }

  override fun setShort(parameterIndex: Int, x: Short) {
    setValue(parameterIndex, x.toString())
  }

  override fun setInt(parameterIndex: Int, x: Int) {
    setValue(parameterIndex, x.toString())
  }

  override fun setLong(parameterIndex: Int, x: Long) {
    setValue(parameterIndex, x.toString())
  }

  override fun setFloat(parameterIndex: Int, x: Float) {
    setValue(parameterIndex, x.toString())
  }

  override fun setDouble(parameterIndex: Int, x: Double) {
    setValue(parameterIndex, x.toString())
  }

  override fun setBigDecimal(parameterIndex: Int, x: BigDecimal?) {
    val value = if (x != null) x.toPlainString() else "NULL"

    setValue(parameterIndex, value)
  }

  override fun setString(parameterIndex: Int, x: String?) {
    val value = if (x != null) "'$x'" else "NULL"

    setValue(parameterIndex, value)
  }

  override fun setDate(parameterIndex: Int, x: Date?) {
    val value = if (x != null) SQL_DATE_FORMAT.format(x.toLocalDate()) else "NULL"

    setValue(parameterIndex, value)
  }

  override fun setDate(parameterIndex: Int, x: Date?, cal: Calendar?) {
    setDate(parameterIndex, x)
  }

  override fun setTime(parameterIndex: Int, x: Time?) {
    val value = if (x != null) SQL_TIME_FORMAT.format(x.toLocalTime()) else "NULL"

    setValue(parameterIndex, value)
  }

  override fun setTime(parameterIndex: Int, x: Time?, cal: Calendar?) {
    setTime(parameterIndex, x)
  }

  override fun setTimestamp(parameterIndex: Int, x: Timestamp?) {
    val value = if (x != null) SQL_TIMESTAMP_FORMAT.format(x.toLocalDateTime()) else "NULL"

    setValue(parameterIndex, value)
  }

  override fun setTimestamp(parameterIndex: Int, x: Timestamp?, cal: Calendar?) {
    setTimestamp(parameterIndex, x)
  }

  //////////////////////////////// Not supported ////////////////////////////////

  override fun getResultSet(): ResultSet {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setAsciiStream(parameterIndex: Int, x: InputStream, length: Int) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setAsciiStream(parameterIndex: Int, x: InputStream, length: Long) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setAsciiStream(parameterIndex: Int, x: InputStream) {
    throw UnsupportedOperationException("Not implemented")
  }

  @Deprecated("Deprecated in Java", ReplaceWith("Dunno"))
  override fun setUnicodeStream(parameterIndex: Int, x: InputStream, length: Int) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setRef(parameterIndex: Int, x: Ref?) {
    throw UnsupportedOperationException("Not implemented")
  }

  @Suppress("RemoveRedundantQualifierName")
  override fun setArray(parameterIndex: Int, x: java.sql.Array?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getMetaData(): ResultSetMetaData {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setURL(parameterIndex: Int, x: URL?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getParameterMetaData(): ParameterMetaData {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setRowId(parameterIndex: Int, x: RowId?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setNString(parameterIndex: Int, value: String?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setNCharacterStream(parameterIndex: Int, value: Reader?, length: Long) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setNCharacterStream(parameterIndex: Int, value: Reader?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setNClob(parameterIndex: Int, value: NClob?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setNClob(parameterIndex: Int, reader: Reader?, length: Long) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setNClob(parameterIndex: Int, reader: Reader?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setSQLXML(parameterIndex: Int, xmlObject: SQLXML?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun <T : Any?> unwrap(iface: Class<T>?): T {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun isWrapperFor(iface: Class<*>?) = false

  override fun executeQuery(): ResultSet {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun executeQuery(sql: String): ResultSet {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getMaxFieldSize(): Int {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setMaxFieldSize(max: Int) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getMaxRows(): Int {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setMaxRows(max: Int) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setEscapeProcessing(enable: Boolean) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getQueryTimeout(): Int {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setQueryTimeout(seconds: Int) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun cancel() {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getWarnings(): SQLWarning {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun clearWarnings() {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setCursorName(name: String?) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getMoreResults(): Boolean {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getMoreResults(current: Int): Boolean {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setFetchDirection(direction: Int) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getFetchDirection(): Int {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setFetchSize(rows: Int) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getFetchSize(): Int {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getResultSetConcurrency(): Int {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getResultSetType(): Int {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getGeneratedKeys(): ResultSet {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun getResultSetHoldability(): Int {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun setPoolable(poolable: Boolean) {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun isPoolable(): Boolean {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun closeOnCompletion() {
    throw UnsupportedOperationException("Not implemented")
  }

  override fun isCloseOnCompletion(): Boolean {
    throw UnsupportedOperationException("Not implemented")
  }
}
