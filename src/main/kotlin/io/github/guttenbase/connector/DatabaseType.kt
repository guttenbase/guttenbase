package io.github.guttenbase.connector

import io.github.guttenbase.meta.ColumnMetaData
import io.github.guttenbase.schema.AutoIncrementValue
import io.github.guttenbase.utils.Util.toHex
import java.sql.Types

/**
 * Bundle knowledge about well-known data bases, e.g.. specific SQL clauses
 *
 *  &copy; 2012-2034 akquinet tech@spree
 *
 * @author M. Dahm
 */
enum class DatabaseType(
  /**
   * ID columns may be defined as autoincremented, i.e. every time data is inserted the ID will be incremented autoimatically.
   * Unfortunately every database has its own way to implement this feature.
   */
  private val autoincrementColumnClause: String,
  private val autoincrementColumnStatement: String? = null
) {
  // Dummy value
  GENERIC("IDENTITY($NEXT_VALUE, 1)"),
  MOCK("IDENTITY($NEXT_VALUE, 1)"),
  EXPORT_DUMP("IDENTITY($NEXT_VALUE, 1)"),
  IMPORT_DUMP("IDENTITY($NEXT_VALUE, 1)"),

  MYSQL("AUTO_INCREMENT", "ALTER TABLE $TABLE_NAME AUTO_INCREMENT = $NEXT_VALUE;"),
  MARIADB("AUTO_INCREMENT", "ALTER TABLE $TABLE_NAME AUTO_INCREMENT = $NEXT_VALUE;"),

  POSTGRESQL(
    "", // Handled by column type, see below)
    "SELECT setval('${TABLE_NAME}_id_seq', $NEXT_VALUE, true);"
  ),
  MSSQL("IDENTITY($NEXT_VALUE, 1)"),

  MS_ACCESS("AUTOINCREMENT($NEXT_VALUE, 1)"),

  DB2("GENERATED BY DEFAULT AS IDENTITY (START WITH $NEXT_VALUE, INCREMENT BY $STEP_VALUE)"),

  SYBASE("IDENTITY", "CALL sa_reset_identity('$TABLE_NAME', 'DBA', $NEXT_VALUE - 1);"),

  ORACLE("GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH $NEXT_VALUE INCREMENT BY $STEP_VALUE"),

  HSQLDB("GENERATED BY DEFAULT AS IDENTITY (START WITH $NEXT_VALUE, INCREMENT BY $STEP_VALUE)"), // IDENTITY
  H2DB(
    "GENERATED BY DEFAULT AS IDENTITY",
    "ALTER TABLE $TABLE_NAME ALTER COLUMN $COLUMN_NAME RESTART WITH $NEXT_VALUE;"
  ), // AUTO_INCREMENT
  DERBY("GENERATED BY DEFAULT AS IDENTITY (START WITH $NEXT_VALUE, INCREMENT BY $STEP_VALUE)")
  ;

  /**
   * To be executed when table DDL script is created
   */
  fun createColumnType(column: ColumnMetaData): String? {
    assert(column.isAutoIncrement) { "$column is no auto increment column" }

    return if (this == POSTGRESQL) {
      when (column.columnType) {
        Types.BIGINT -> "BIGSERIAL"
        Types.INTEGER -> "SERIAL"
        Types.SMALLINT -> "SMALLSERIAL"
        else -> "SERIAL"
      }
    } else {
      null
    }
  }

  /**
   * To be executed when table DDL script is created
   */
  fun createColumnAutoincrementClause(column: ColumnMetaData): String {
    assert(column.isAutoIncrement) { "$column is no auto increment column" }

    val autoIncrementValue = retrieveAutoIncrementValue(column)
    val startValue = autoIncrementValue.startValue(column)
    val stepValue = autoIncrementValue.stepWidth(column)

    return autoincrementColumnClause.replace(NEXT_VALUE, startValue.toString())
      .replace(STEP_VALUE, stepValue.toString())
      .replace(TABLE_NAME, column.tableMetaData.tableName).replace(COLUMN_NAME, column.columnName)
  }

  /**
   * To be executed after table DDL script has run (optionally)
   */
  fun createColumnAutoincrementStatement(column: ColumnMetaData): String? {
    assert(column.isAutoIncrement) { "$column is no auto increment column" }

    return if (autoincrementColumnStatement != null) {
      val autoIncrementValue = retrieveAutoIncrementValue(column)
      val startValue = autoIncrementValue.startValue(column)
      val stepValue = autoIncrementValue.stepWidth(column)

      autoincrementColumnStatement.replace(NEXT_VALUE, startValue.toString()).replace(STEP_VALUE, stepValue.toString())
        .replace(TABLE_NAME, column.tableMetaData.tableName).replace(COLUMN_NAME, column.columnName)
    } else {
      null
    }
  }

  // TODO
  fun createBlobDataClause(data: ByteArray): String {
    val hex = data.toHex()

    return when (this) {
      POSTGRESQL -> """E'\\x$hex'"""
      SYBASE, MSSQL, MYSQL -> """0x$hex"""
      ORACLE -> """'$hex'"""
      DB2 -> """BLOB(x'$hex')"""
      H2DB, HSQLDB, DERBY -> """CAST (X'$hex' AS BLOB)"""
      else -> """CAST (X'$hex' AS BLOB)""" // Hope for the best...
    }
  }

  private fun retrieveAutoIncrementValue(column: ColumnMetaData): AutoIncrementValue {
    val connectorRepository = column.tableMetaData.databaseMetaData.connectorRepository
    val connectorId = column.tableMetaData.databaseMetaData.connectorId

    return connectorRepository.getConnectorHint(connectorId, AutoIncrementValue::class.java).value
  }
}

private const val NEXT_VALUE = "@@NEXT_VALUE@@"
private const val STEP_VALUE = "@@STEP_VALUE@@"
private const val TABLE_NAME = "@@TABLE_NAME@@"
private const val COLUMN_NAME = "@@COLUMN_NAME@@"
